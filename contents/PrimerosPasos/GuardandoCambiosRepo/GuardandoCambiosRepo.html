<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Guardando cambios en el repositorio</title>
		<link rel="shortcut icon" type="image/x-icon" href="../../../../../KonoMngr/style/icons/konoicn.png">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" type="text/css" href="../../../../../KonoMngr/style/konoguides.css" />
		<script src="../../../../../KonoMngr/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
  				TeX: { equationNumbers: { autoNumber: "AMS" } }
			});</script>
		<link rel="stylesheet" href="../../../../../KonoMngr/highlight/styles/googlecode.css">
		<script src="../../../../../KonoMngr/highlight/highlight.pack.js" type="text/javascript"></script>
		<script>hljs.initHighlightingOnLoad();</script>		
	</head>
	
	<body class="kg-content">
		<header>
			<h1>Guardando cambios en el repositorio</h1>
		</header>
		
		<article class="subsection">
			<p>Tienes un repositorio Git completo, y una <em>copia de trabajo</em> de los archivos de ese proyecto. Necesitas hacer algunos cambios, y <em>confirmar instantáneas</em> de esos cambios a tu repositorio cada vez que el proyecto alcance un estado que desees grabar.</p>
			<p>Cada archivo de tu directorio de trabajo puede estar en uno de estos dos estados:</p>
			<ul>
			    <li><em>bajo seguimiento</em> <b>(tracked)</b>: son aquellos archivos que existían en la última instantánea; pueden estar:
			        <ul>
			            <li>sin modificaciones,</li>
			            <li>modificados,</li>
			            <li>preparados</li>
			        </ul>
			        
			    </li>
			    <li><em>sin seguimiento</em> <b>(untracked)</b>: son todos los demás archivos &mdash;cualquier archivo de tu directorio que no estuviese en tu última instantánea ni está en tu área de preparación.</li>
			</ul>
			<article class="note">La primera vez que clonas un repositorio, todos tus archivos estarán bajo seguimiento y sin modificaciones, ya que los acabas de copiar y no has modificado nada.</article>
			
			<p>A medida que editas archivos, Git los ve como <em>modificados</em>, porque los has cambiado desde tu última confirmación. <em>Preparas</em> estos archivos modificados <em>y luego confirmas</em> todos los cambios que hayas preparado, y el ciclo se repite. Este proceso queda ilustrado en la siguiente figura.</p>
			<figure>
			    <img src="media/CicloVida.png" alt="alt-text" width="px" height="px">
			    <figcaption>El ciclo de vida del estado de los archivos de un repositorio</figcaption>
			</figure>
			
			<p>A continuación de abordan diferentes tópicos de carcater práctico para el manejo del repositorio. Estos son:</p>
			<li><a href="#COMPESTADO" target="_self">Comprobando el estado de tus archivos</a></li>
			<li><a href="#SIGUIENDONA" target="_self">Seguimiento de nuevos archivos</a></li>
			<li><a href="#PREPARANDO_ARCHIVOS" target="_self">Preparando archivos modificados</a></li>
			<li><a href="#IGNORANDOA" target="_self">Ignorando archivos</a></li>
			<li><a href="#CAMBIOSPREPNOPREP" target="_self">Viendo tus cambios preparados y no preparados</a></li>
			<li><a href="#CONFIRMCAMBIOS" target="_self">Confirmando tus cambios</a></li>
			<li><a href="#SALTAR_PREP" target="_self">Saltándote el área de preparación</a></li>
			<li><a href="#ELIMARCHIVOS" target="_self">Eliminando archivos</a></li>
			<li><a href="#MOVERARCHIVOS" target="_self">Moviendo archivos</a></li>
			
		</article>
		
		<article class="subsection">
		    <h1 id="COMPESTADO">Comprobando el estado de tus archivos</h1>
		    <p>La principal herramienta para determinar qué archivos están en qué estado es el comando <em>git status</em>. Si ejecutas este comando justo después de clonar un repositorio, deberías ver algo así:</p>
		    <pre><code>$ git status
# On branch master
nothing to commit, working directory clean</code></pre>
            <p>Digamos que <em>añades un nuevo archivo</em> a tu proyecto, un sencillo archivo <em>README</em>. Si el archivo no existía y ejecutas git status, verás tus archivos sin seguimiento así:</p>
            <pre><code>$ git status
# On branch master
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be committed)
#
#   README
nothing added to commit but untracked files present (use "git add" to track)</code></pre>
            <p>Puedes ver que tu nuevo archivo README aparece bajo la cabecera <em>“Archivos sin seguimiento” (“Untracked files”)</em> de la salida del comando. Sin seguimiento significa básicamente que Git ve <em>un archivo que no estaba en la instantánea anterior</em>; Git no empezará a incluirlo en las confirmaciones de tus instantáneas hasta que se lo indiques explícitamente. Lo hace <em>para que no incluyas accidentalmente archivos</em> binarios generados u otros archivos que no tenías intención de incluir. </p>
		</article>
		
		<article class="subsection">
		    <h1 id="SIGUIENDONA">Seguimiento de nuevos archivos</h1>
		    <p>Para empezar el seguimiento de un nuevo archivo se usa el comando <em>git add</em>:</p>
		    <pre><code>git add [file|DIR]</code></pre>
		    <p>El comando <em>git add</em> recibe la ruta de un archivo o de un directorio; si es un directorio, añade todos los archivos que contenga de manera recursiva.</p>
		    <p>Una vez que se ha agregado una archivo para seguimiento podr+as ver con <em>git status</em> que el archivo está preparado porque aparecerá bajo la cabecera <em>"Cambios a confirmar"  (“Changes to be committed”)</em>. Si confirmas ahora, la versión del archivo en el momento de ejecutar <em>git add</em> será la que se incluya en la instantánea.</p>
		    <pre><code>$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#   new file:   README
#</code></pre>
		</article>
		
		<article class="subsection">
		    <h1 id="PREPARANDO_ARCHIVOS">Preparando archivos modificados</h1>
		    <p>Si modificas un archivo que ya se encuentra bajo seguimiento, git le asignará el status <em>“Modificados pero no actualizados” (“Changes not staged for commit”)</em>, esto significa que el archivo ha sido modificado en el directorio de trabajo, pero no ha sido preparado todavía.</p>
		    <p>Para prepararlo, ejecuta el comando <b>git add</b> seguido del nombre del archivo. Como puedes ver <em>git add</em> es un comando multiuso, puedes utilizarlo, por ejemplo, para:</p>
		    <ul>
		        <li>empezar el seguimiento de archivos nuevos,</li>
		        <li>preparar archivos,</li>
		        <li>marcar como resueltos archivos con conflictos de unión.</li>
		    </ul>
		</article>
		
		<article class="subsection">
		    <h1 id="IGNORANDOA">Ignorando archivos</h1>
		    <p>A menudo tendrás un tipo de archivos que no quieras que Git añada automáticamente o te muestre como no versionado. Suelen ser archivos generados automáticamente, como archivos de log, o archivos generados por tu compilador. Para estos casos puedes <em>crear un archivo llamado</em> <b>.gitignore</b> en la raiz de tu directorio, en el que listas los patrones de nombres que deseas que sean ignorados. He aquí un archivo .gitignore de ejemplo:</p>
		    <pre><code>*.[oa]
*~</code></pre>
            <ul>
                <li>La primera línea le dice a Git que ignore cualquier archivo cuyo nombre termine en .o o .a</li>
                <li>La segunda línea le dice a Git que ignore todos los archivos que terminan en tilde (~), usada por muchos editores de texto, como Emacs, para marcar archivos temporales.</li>
            </ul>
            <p>También puedes incluir directorios de log, temporales, documentación generada automáticamente, etc. Configurar un archivo .gitignore antes<em></em> de empezar a trabajar suele ser una buena idea, para así no confirmar archivos que no quieres en tu repositorio Git.</p>
            
            <h2 id="">reglas para los patrones</h2>
            <p>Las reglas para los patrones que pueden ser incluidos en el archivo <em>.gitignore</em> son:</p>
            <ul>
                <li>Las líneas en blanco, o que comienzan por <em></em>#, son ignoradas.</li>
                <li>Puedes usar <em>patrones glob</em> estándar.</li>
                <li>Puedes indicar un <em>directorio</em> añadiendo una barra hacia delante <em>(/)</em> al final.</li>
                <li>Puedes <em>negar</em> un patrón añadiendo una exclamación <em>(!)</em> al principio.</li>
            </ul>
            <p>Los <em>patrones glob</em> son <em>expresiones regulares simplificadas</em> que pueden ser usadas por las shells. Un asterisco <em>(*)</em> reconoce cero o más caracteres; <em>[abc]</em> reconoce cualquier carácter de los especificados entre corchetes (en este caso, a, b o c); una interrogación <em>(?)</em> reconoce un único carácter; y caracteres entre corchetes separados por un guión <em>([0-9])</em> reconoce cualquier carácter entre ellos (en este caso, de 0 a 9).</p>
            <p>He aquí otro ejemplo de archivo <em>.gitignore</em>:</p>
            <pre><code># a comment – this is ignored
# no .a files
*.a
# but do track lib.a, even though you're ignoring .a files above
!lib.a
# only ignore the root TODO file, not subdir/TODO
/TODO
# ignore all files in the build/ directory
build/
# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt
# ignore all .txt files in the doc/ directory
doc/**/*.txt</code></pre>
            
		    
		</article>
		
	</body>
</html>	
